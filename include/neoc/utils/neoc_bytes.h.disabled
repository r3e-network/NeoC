/**
 * @file neoc_bytes.h
 * @brief Byte manipulation utilities
 *
 * This file provides utility functions for byte array operations including
 * padding, trimming, reversing, and other common manipulations.
 */

#ifndef NEOC_UTILS_BYTES_H
#define NEOC_UTILS_BYTES_H

#include "../neoc_error.h"
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @defgroup ByteUtils Byte Utilities
 * @brief Utility functions for byte array manipulation
 * @{
 */

/**
 * @brief Reverse bytes in place
 * @param data Data to reverse
 * @param length Length of data
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_reverse(uint8_t* data, size_t length);

/**
 * @brief Copy and reverse bytes
 * @param src Source data
 * @param src_len Source length
 * @param dst Destination buffer
 * @param dst_len Destination buffer size
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_reverse_copy(const uint8_t* src, size_t src_len,
                                     uint8_t* dst, size_t dst_len);

/**
 * @brief Pad bytes to specified length
 * @param src Source data
 * @param src_len Source length
 * @param target_len Target length after padding
 * @param trailing Whether to pad at the end (true) or beginning (false)
 * @param result Pointer to store padded result
 * @param result_len Pointer to store result length
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_pad(const uint8_t* src, size_t src_len,
                           size_t target_len, bool trailing,
                           uint8_t** result, size_t* result_len);

/**
 * @brief Trim trailing bytes of specified value
 * @param src Source data
 * @param src_len Source length
 * @param byte_value Byte value to trim
 * @param result Pointer to store trimmed result
 * @param result_len Pointer to store result length
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_trim_trailing(const uint8_t* src, size_t src_len,
                                      uint8_t byte_value,
                                      uint8_t** result, size_t* result_len);

/**
 * @brief XOR two byte arrays
 * @param lhs Left-hand side array
 * @param rhs Right-hand side array
 * @param length Length of both arrays (must be equal)
 * @param result Result array
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_xor(const uint8_t* lhs, const uint8_t* rhs,
                            size_t length, uint8_t* result);

/**
 * @brief Convert bytes to script hash address
 * @param script_hash Script hash bytes (20 bytes)
 * @param address_version Address version byte
 * @param address Output buffer for address string
 * @param address_size Size of address buffer
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_script_hash_to_address(const uint8_t* script_hash,
                                               uint8_t address_version,
                                               char* address, size_t address_size);

/**
 * @brief Calculate variable length size encoding
 * @param value Value to encode
 * @return Number of bytes needed for variable length encoding
 */
size_t neoc_bytes_var_size(size_t value);

/**
 * @brief Encode variable length size
 * @param value Value to encode
 * @param buffer Output buffer
 * @param buffer_size Buffer size
 * @param bytes_written Pointer to store number of bytes written
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_encode_var_size(size_t value, uint8_t* buffer,
                                        size_t buffer_size, size_t* bytes_written);

/**
 * @brief Decode variable length size
 * @param buffer Input buffer
 * @param buffer_size Buffer size
 * @param value Pointer to store decoded value
 * @param bytes_read Pointer to store number of bytes read
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_decode_var_size(const uint8_t* buffer, size_t buffer_size,
                                        size_t* value, size_t* bytes_read);

/**
 * @brief Check if byte is between two opcode values
 * @param byte Byte to check
 * @param op1 First opcode value
 * @param op2 Second opcode value
 * @return true if byte is between opcodes, false otherwise
 */
bool neoc_byte_is_between_opcodes(uint8_t byte, uint8_t op1, uint8_t op2);

/**
 * @brief Convert bytes to little-endian numeric value
 * @param bytes Input bytes
 * @param length Number of bytes
 * @param result Pointer to store result (up to 8 bytes)
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_to_uint64_le(const uint8_t* bytes, size_t length,
                                     uint64_t* result);

/**
 * @brief Convert bytes to big-endian numeric value
 * @param bytes Input bytes
 * @param length Number of bytes
 * @param result Pointer to store result (up to 8 bytes)
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_bytes_to_uint64_be(const uint8_t* bytes, size_t length,
                                     uint64_t* result);

/**
 * @brief Convert numeric value to bytes (little-endian)
 * @param value Value to convert
 * @param bytes Output buffer
 * @param length Number of bytes to write
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_uint64_to_bytes_le(uint64_t value, uint8_t* bytes, size_t length);

/**
 * @brief Convert numeric value to bytes (big-endian)
 * @param value Value to convert
 * @param bytes Output buffer
 * @param length Number of bytes to write
 * @return NEOC_SUCCESS on success, error code on failure
 */
neoc_error_t neoc_uint64_to_bytes_be(uint64_t value, uint8_t* bytes, size_t length);

/** @} */ // end of ByteUtils

#ifdef __cplusplus
}
#endif

#endif // NEOC_UTILS_BYTES_H